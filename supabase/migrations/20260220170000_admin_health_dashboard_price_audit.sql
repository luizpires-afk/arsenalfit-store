begin;

create extension if not exists pgcrypto;

alter table public.products
  add column if not exists affiliate_validation_status text not null default 'PENDING',
  add column if not exists affiliate_validation_error text,
  add column if not exists removed_at timestamptz,
  add column if not exists removed_reason text,
  add column if not exists removed_by text,
  add column if not exists removed_note text,
  add column if not exists price_mismatch_status text not null default 'NONE',
  add column if not exists expected_price numeric,
  add column if not exists site_price_snapshot numeric,
  add column if not exists last_price_audit_at timestamptz,
  add column if not exists price_mismatch_reason text,
  add column if not exists price_mismatch_resolved_at timestamptz;

update public.products
set affiliate_validation_status = case
  when lower(coalesce(marketplace, '')) like 'mercado%'
    and coalesce(is_active, false) = true
    and lower(coalesce(status, '')) = 'active'
    and public.is_mercadolivre_sec_link(affiliate_link)
  then 'VALIDATED'
  else coalesce(nullif(affiliate_validation_status, ''), 'PENDING')
end,
affiliate_validation_error = case
  when lower(coalesce(marketplace, '')) like 'mercado%'
    and public.is_mercadolivre_sec_link(affiliate_link)
  then null
  else affiliate_validation_error
end
where true;

do $$
begin
  alter table public.products drop constraint if exists products_affiliate_validation_status_check;
  alter table public.products
    add constraint products_affiliate_validation_status_check
    check (
      affiliate_validation_status in (
        'PENDING',
        'VALIDATED',
        'INVALID_NOT_PERMITTED',
        'INVALID_LINK',
        'INVALID_DUPLICATE',
        'ERROR'
      )
    );
exception
  when undefined_table then
    null;
end $$;

do $$
begin
  alter table public.products drop constraint if exists products_price_mismatch_status_check;
  alter table public.products
    add constraint products_price_mismatch_status_check
    check (
      price_mismatch_status in ('NONE', 'OPEN', 'RESOLVED')
    );
exception
  when undefined_table then
    null;
end $$;

do $$
begin
  alter table public.products drop constraint if exists products_data_health_status_check;
  alter table public.products
    add constraint products_data_health_status_check
    check (
      data_health_status in (
        'HEALTHY',
        'DUPLICATE',
        'INVALID_SOURCE',
        'API_MISSING',
        'SCRAPE_FAILED',
        'SUSPECT_PRICE',
        'NEEDS_REVIEW',
        'PRICE_MISMATCH'
      )
    );
exception
  when undefined_table then
    null;
end $$;

create index if not exists idx_products_affiliate_validation_status
  on public.products (affiliate_validation_status, updated_at desc);

create index if not exists idx_products_removed_at
  on public.products (removed_at desc);

create index if not exists idx_products_price_mismatch_status
  on public.products (price_mismatch_status, last_price_audit_at desc);

create table if not exists public.product_admin_actions (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  product_id uuid null references public.products(id) on delete set null,
  admin_user_id uuid null references auth.users(id) on delete set null,
  action text not null,
  reason text null,
  note text null,
  details jsonb not null default '{}'::jsonb
);

create index if not exists idx_product_admin_actions_created
  on public.product_admin_actions (created_at desc);

create index if not exists idx_product_admin_actions_product
  on public.product_admin_actions (product_id, created_at desc);

alter table public.product_admin_actions enable row level security;

drop policy if exists "product_admin_actions_admin_read" on public.product_admin_actions;
create policy "product_admin_actions_admin_read"
  on public.product_admin_actions
  for select
  to authenticated
  using (public.has_role(auth.uid(), 'admin'));

drop policy if exists "product_admin_actions_admin_manage" on public.product_admin_actions;
create policy "product_admin_actions_admin_manage"
  on public.product_admin_actions
  for all
  to authenticated
  using (public.has_role(auth.uid(), 'admin'))
  with check (public.has_role(auth.uid(), 'admin'));

drop policy if exists "product_admin_actions_service_manage" on public.product_admin_actions;
create policy "product_admin_actions_service_manage"
  on public.product_admin_actions
  for all
  to service_role
  using (true)
  with check (true);

create table if not exists public.price_mismatch_cases (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  product_id uuid not null references public.products(id) on delete cascade,
  site_price numeric not null,
  ml_price numeric not null,
  delta_abs numeric not null,
  delta_pct numeric not null,
  status text not null default 'OPEN',
  source text not null default 'price_audit',
  reason text null,
  last_audit_at timestamptz not null default now(),
  resolved_at timestamptz null,
  resolved_by text null,
  resolution_note text null,
  metadata jsonb not null default '{}'::jsonb
);

do $$
begin
  alter table public.price_mismatch_cases drop constraint if exists price_mismatch_cases_status_check;
  alter table public.price_mismatch_cases
    add constraint price_mismatch_cases_status_check
    check (status in ('OPEN', 'RESOLVED', 'DISMISSED'));
exception
  when undefined_table then
    null;
end $$;

create index if not exists idx_price_mismatch_cases_status
  on public.price_mismatch_cases (status, delta_pct desc, updated_at desc);

create index if not exists idx_price_mismatch_cases_product
  on public.price_mismatch_cases (product_id, created_at desc);

create unique index if not exists idx_price_mismatch_cases_open_product
  on public.price_mismatch_cases (product_id)
  where status = 'OPEN';

alter table public.price_mismatch_cases enable row level security;

drop policy if exists "price_mismatch_cases_admin_read" on public.price_mismatch_cases;
create policy "price_mismatch_cases_admin_read"
  on public.price_mismatch_cases
  for select
  to authenticated
  using (public.has_role(auth.uid(), 'admin'));

drop policy if exists "price_mismatch_cases_admin_manage" on public.price_mismatch_cases;
create policy "price_mismatch_cases_admin_manage"
  on public.price_mismatch_cases
  for all
  to authenticated
  using (public.has_role(auth.uid(), 'admin'))
  with check (public.has_role(auth.uid(), 'admin'));

drop policy if exists "price_mismatch_cases_service_manage" on public.price_mismatch_cases;
create policy "price_mismatch_cases_service_manage"
  on public.price_mismatch_cases
  for all
  to service_role
  using (true)
  with check (true);

create or replace function public.admin_soft_remove_standby_products(
  p_product_ids uuid[],
  p_reason text,
  p_note text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_ids uuid[] := coalesce(p_product_ids, array[]::uuid[]);
  v_reason text := upper(coalesce(nullif(btrim(p_reason), ''), 'OTHER'));
  v_note text := nullif(btrim(coalesce(p_note, '')), '');
  v_now timestamptz := now();
  v_admin uuid := auth.uid();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_requested integer := 0;
  v_removed integer := 0;
  v_skipped_active integer := 0;
  rec record;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  if array_length(v_ids, 1) is null then
    return jsonb_build_object('ok', false, 'error', 'empty_product_ids');
  end if;

  if v_reason not in ('INVALID_AFFILIATE', 'IRRELEVANT_RESULT', 'DUPLICATE', 'PRICE_MISMATCH', 'OUT_OF_STOCK', 'OTHER') then
    raise exception 'invalid_reason';
  end if;

  for rec in
    select
      p.id,
      p.name,
      p.status,
      p.is_active,
      p.affiliate_link,
      p.data_health_status
    from public.products p
    where p.id = any(v_ids)
    for update
  loop
    v_requested := v_requested + 1;

    if coalesce(rec.is_active, false)
      and lower(coalesce(rec.status, '')) = 'active'
      and public.is_mercadolivre_sec_link(rec.affiliate_link)
    then
      v_skipped_active := v_skipped_active + 1;
      continue;
    end if;

    update public.products
      set status = 'archived',
          is_active = false,
          removed_at = v_now,
          removed_reason = v_reason,
          removed_by = coalesce(v_admin::text, 'service_role'),
          removed_note = v_note,
          deactivation_reason = coalesce(deactivation_reason, 'removed_by_admin'),
          auto_disabled_reason = coalesce(auto_disabled_reason, 'removed_by_admin'),
          auto_disabled_at = coalesce(auto_disabled_at, v_now),
          data_health_status = case
            when v_reason = 'DUPLICATE' then 'DUPLICATE'
            when v_reason = 'PRICE_MISMATCH' then 'PRICE_MISMATCH'
            when v_reason = 'INVALID_AFFILIATE' then 'INVALID_SOURCE'
            else coalesce(rec.data_health_status, 'NEEDS_REVIEW')
          end,
          affiliate_validation_status = case
            when v_reason = 'INVALID_AFFILIATE' then 'INVALID_NOT_PERMITTED'
            else affiliate_validation_status
          end,
          affiliate_validation_error = case
            when v_reason = 'INVALID_AFFILIATE' then coalesce(affiliate_validation_error, 'URL nao permitido pelo Programa')
            else affiliate_validation_error
          end,
          last_health_check_at = v_now,
          updated_at = v_now
    where id = rec.id;

    insert into public.product_admin_actions (
      product_id,
      admin_user_id,
      action,
      reason,
      note,
      details
    )
    values (
      rec.id,
      v_admin,
      'soft_remove_standby',
      v_reason,
      v_note,
      jsonb_build_object(
        'old_status', rec.status,
        'old_is_active', rec.is_active
      )
    );

    v_removed := v_removed + 1;
  end loop;

  return jsonb_build_object(
    'ok', true,
    'requested', v_requested,
    'removed', v_removed,
    'skipped_active', v_skipped_active
  );
end;
$$;

create or replace function public.run_price_mismatch_audit(
  p_lookback_hours integer default 24,
  p_warn_pct numeric default 25,
  p_warn_abs numeric default 20,
  p_critical_pct numeric default 50,
  p_critical_abs numeric default 30,
  p_apply_critical_policy boolean default true
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_now timestamptz := now();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_admin uuid := auth.uid();
  v_processed integer := 0;
  v_opened integer := 0;
  v_critical integer := 0;
  v_lookback integer := greatest(coalesce(p_lookback_hours, 24), 1);
  v_warn_pct numeric := greatest(coalesce(p_warn_pct, 25), 0);
  v_warn_abs numeric := greatest(coalesce(p_warn_abs, 20), 0);
  v_critical_pct numeric := greatest(coalesce(p_critical_pct, 50), 0);
  v_critical_abs numeric := greatest(coalesce(p_critical_abs, 30), 0);
  v_expected numeric;
  v_source text;
  v_delta_abs numeric;
  v_delta_pct numeric;
  v_is_critical boolean;
  rec record;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  for rec in
    with latest_anomaly as (
      select distinct on (a.product_id)
        a.product_id,
        a.detected_at,
        a.note,
        a.price_from_catalog,
        a.price_from_item
      from public.price_sync_anomalies a
      where a.detected_at >= (v_now - make_interval(hours => v_lookback))
      order by a.product_id, a.detected_at desc
    )
    select
      la.product_id,
      la.detected_at,
      la.note,
      la.price_from_catalog,
      la.price_from_item,
      p.price as site_price
    from latest_anomaly la
    join public.products p on p.id = la.product_id
    where lower(coalesce(p.marketplace, '')) like 'mercado%'
      and p.removed_at is null
      and coalesce(p.price, 0) > 0
      and (
        coalesce(la.price_from_catalog, 0) > 0
        or coalesce(la.price_from_item, 0) > 0
      )
  loop
    v_processed := v_processed + 1;

    if coalesce(rec.price_from_item, 0) > 0 then
      v_expected := rec.price_from_item;
      v_source := 'item';
    elsif coalesce(rec.price_from_catalog, 0) > 0 then
      v_expected := rec.price_from_catalog;
      v_source := 'catalog';
    else
      continue;
    end if;

    v_delta_abs := abs(rec.site_price - v_expected);
    v_delta_pct := case
      when greatest(rec.site_price, v_expected) <= 0 then 0
      else (v_delta_abs / greatest(rec.site_price, v_expected)) * 100
    end;

    if v_delta_pct >= v_warn_pct or v_delta_abs >= v_warn_abs then
      v_is_critical := v_delta_pct >= v_critical_pct or v_delta_abs >= v_critical_abs;

      update public.price_mismatch_cases
        set site_price = rec.site_price,
            ml_price = v_expected,
            delta_abs = v_delta_abs,
            delta_pct = v_delta_pct,
            source = v_source,
            reason = coalesce(rec.note, 'price_mismatch'),
            last_audit_at = v_now,
            updated_at = v_now,
            metadata = jsonb_build_object(
              'price_from_catalog', rec.price_from_catalog,
              'price_from_item', rec.price_from_item,
              'detected_at', rec.detected_at,
              'critical', v_is_critical
            )
      where product_id = rec.product_id
        and status = 'OPEN';

      if not found then
        insert into public.price_mismatch_cases (
          product_id,
          site_price,
          ml_price,
          delta_abs,
          delta_pct,
          status,
          source,
          reason,
          last_audit_at,
          metadata
        )
        values (
          rec.product_id,
          rec.site_price,
          v_expected,
          v_delta_abs,
          v_delta_pct,
          'OPEN',
          v_source,
          coalesce(rec.note, 'price_mismatch'),
          v_now,
          jsonb_build_object(
            'price_from_catalog', rec.price_from_catalog,
            'price_from_item', rec.price_from_item,
            'detected_at', rec.detected_at,
            'critical', v_is_critical
          )
        );
        v_opened := v_opened + 1;
      end if;

      update public.products
        set data_health_status = 'PRICE_MISMATCH',
            price_mismatch_status = 'OPEN',
            expected_price = v_expected,
            site_price_snapshot = rec.site_price,
            last_price_audit_at = v_now,
            price_mismatch_reason = coalesce(rec.note, 'price_mismatch'),
            last_health_check_at = v_now,
            status = case
              when p_apply_critical_policy and v_is_critical then 'standby'
              else status
            end,
            is_active = case
              when p_apply_critical_policy and v_is_critical then false
              else is_active
            end,
            deactivation_reason = case
              when p_apply_critical_policy and v_is_critical then 'price_mismatch_critical'
              else deactivation_reason
            end,
            auto_disabled_reason = case
              when p_apply_critical_policy and v_is_critical then 'price_mismatch_critical'
              else auto_disabled_reason
            end,
            auto_disabled_at = case
              when p_apply_critical_policy and v_is_critical then v_now
              else auto_disabled_at
            end,
            updated_at = v_now
      where id = rec.product_id;

      if p_apply_critical_policy and v_is_critical then
        v_critical := v_critical + 1;
      end if;
    end if;
  end loop;

  return jsonb_build_object(
    'ok', true,
    'processed', v_processed,
    'opened', v_opened,
    'critical', v_critical
  );
end;
$$;

create or replace function public.auto_fix_open_price_mismatch_cases(
  p_limit integer default 50,
  p_source_only_item boolean default true
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_now timestamptz := now();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_admin uuid := auth.uid();
  v_limit integer := greatest(coalesce(p_limit, 50), 1);
  v_total integer := 0;
  v_resolved integer := 0;
  v_reactivated integer := 0;
  v_skipped integer := 0;
  v_reactivated_now boolean;
  rec record;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  for rec in
    select
      c.id as case_id,
      c.product_id,
      c.ml_price,
      c.source,
      p.status as product_status,
      p.is_active,
      p.price as current_price,
      p.affiliate_link,
      p.deactivation_reason,
      p.auto_disabled_reason
    from public.price_mismatch_cases c
    join public.products p on p.id = c.product_id
    where c.status = 'OPEN'
      and p.removed_at is null
      and coalesce(c.ml_price, 0) > 0
      and (not p_source_only_item or c.source = 'item')
    order by c.delta_pct desc nulls last, c.updated_at asc
    limit v_limit
  loop
    v_total := v_total + 1;
    v_reactivated_now := false;

    update public.products
      set previous_price = case
            when coalesce(price, 0) > rec.ml_price then price
            else previous_price
          end,
          previous_price_source = case
            when coalesce(price, 0) > rec.ml_price then 'HISTORY'
            else previous_price_source
          end,
          previous_price_expires_at = case
            when coalesce(price, 0) > rec.ml_price then (v_now + interval '48 hours')
            else previous_price_expires_at
          end,
          price = rec.ml_price,
          data_health_status = 'HEALTHY',
          price_mismatch_status = 'RESOLVED',
          expected_price = null,
          site_price_snapshot = null,
          last_price_audit_at = v_now,
          price_mismatch_reason = null,
          price_mismatch_resolved_at = v_now,
          status = case
            when coalesce(is_active, false) = false
              and lower(coalesce(status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(affiliate_link)
            then 'active'
            else status
          end,
          is_active = case
            when coalesce(is_active, false) = false
              and lower(coalesce(status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(affiliate_link)
            then true
            else is_active
          end,
          deactivation_reason = case
            when coalesce(is_active, false) = false
              and lower(coalesce(status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(affiliate_link)
            then null
            else deactivation_reason
          end,
          auto_disabled_reason = case
            when coalesce(is_active, false) = false
              and lower(coalesce(status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(auto_disabled_reason, '')) = 'price_mismatch_critical'
              and public.is_mercadolivre_sec_link(affiliate_link)
            then null
            else auto_disabled_reason
          end,
          auto_disabled_at = case
            when coalesce(is_active, false) = false
              and lower(coalesce(status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(auto_disabled_reason, '')) = 'price_mismatch_critical'
              and public.is_mercadolivre_sec_link(affiliate_link)
            then null
            else auto_disabled_at
          end,
          last_health_check_at = v_now,
          updated_at = v_now
    where id = rec.product_id;

    select coalesce(p.is_active, false) = true and lower(coalesce(p.status, '')) = 'active'
    into v_reactivated_now
    from public.products p
    where p.id = rec.product_id;

    update public.price_mismatch_cases
      set status = 'RESOLVED',
          resolved_at = v_now,
          resolved_by = coalesce(v_admin::text, 'service_role'),
          resolution_note = 'auto_apply_ml_price',
          updated_at = v_now
    where id = rec.case_id;

    insert into public.product_admin_actions (
      product_id,
      admin_user_id,
      action,
      reason,
      note,
      details
    )
    values (
      rec.product_id,
      v_admin,
      'price_mismatch_auto_fix',
      'auto_apply_ml_price',
      null,
      jsonb_build_object(
        'case_id', rec.case_id,
        'source', rec.source,
        'old_price', rec.current_price,
        'new_price', rec.ml_price,
        'reactivated', v_reactivated_now
      )
    );

    v_resolved := v_resolved + 1;
    if v_reactivated_now then
      v_reactivated := v_reactivated + 1;
    end if;
  end loop;

  v_skipped := greatest(v_total - v_resolved, 0);

  return jsonb_build_object(
    'ok', true,
    'processed', v_total,
    'resolved', v_resolved,
    'reactivated', v_reactivated,
    'skipped', v_skipped
  );
end;
$$;

create or replace function public.queue_price_audit_sample(
  p_limit integer default 60,
  p_include_suspect boolean default true
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_limit integer := greatest(1, least(coalesce(p_limit, 60), 200));
  v_now timestamptz := now();
  v_admin uuid := auth.uid();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_queued integer := 0;
  rec record;
  v_audit jsonb;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  for rec in
    with candidates as (
      select p.id
      from public.products p
      where lower(coalesce(p.marketplace, '')) like 'mercado%'
        and p.removed_at is null
        and lower(coalesce(p.status, '')) in ('active', 'standby', 'paused')
      order by
        case when p.data_health_status = 'SUSPECT_PRICE' then 0 else 1 end,
        case when p.is_featured then 0 else 1 end,
        coalesce(p.clicks_count, 0) desc,
        coalesce(p.last_sync, p.updated_at, p.created_at) desc
      limit v_limit
    )
    select c.id from candidates c
  loop
    if public.enqueue_price_check_refresh(rec.id, true, 'admin_price_audit_sample') then
      v_queued := v_queued + 1;
    end if;
  end loop;

  if p_include_suspect then
    for rec in
      select p.id
      from public.products p
      where lower(coalesce(p.marketplace, '')) like 'mercado%'
        and p.removed_at is null
        and p.data_health_status in ('SUSPECT_PRICE', 'PRICE_MISMATCH')
      order by coalesce(p.last_health_check_at, p.updated_at, p.created_at) asc
      limit 200
    loop
      if public.enqueue_price_check_refresh(rec.id, true, 'admin_recheck_suspect') then
        v_queued := v_queued + 1;
      end if;
    end loop;
  end if;

  v_audit := public.run_price_mismatch_audit(24, 25, 20, 50, 30, true);

  insert into public.product_admin_actions (
    product_id,
    admin_user_id,
    action,
    reason,
    note,
    details
  )
  values (
    null,
    v_admin,
    'queue_price_audit_sample',
    null,
    null,
    jsonb_build_object('queued', v_queued, 'audit', v_audit, 'at', v_now)
  );

  return jsonb_build_object(
    'ok', true,
    'queued', v_queued,
    'audit', v_audit
  );
end;
$$;

create or replace function public.recheck_suspect_prices_now(
  p_limit integer default 200
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_limit integer := greatest(1, least(coalesce(p_limit, 200), 500));
  v_admin uuid := auth.uid();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_queued integer := 0;
  rec record;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  for rec in
    select p.id
    from public.products p
    where lower(coalesce(p.marketplace, '')) like 'mercado%'
      and p.removed_at is null
      and p.data_health_status in ('SUSPECT_PRICE', 'PRICE_MISMATCH')
    order by coalesce(p.last_health_check_at, p.updated_at, p.created_at) asc
    limit v_limit
  loop
    if public.enqueue_price_check_refresh(rec.id, true, 'admin_recheck_suspect') then
      v_queued := v_queued + 1;
    end if;
  end loop;

  return jsonb_build_object(
    'ok', true,
    'queued', v_queued
  );
end;
$$;

create or replace function public.admin_resolve_price_mismatch_case(
  p_case_id uuid,
  p_action text,
  p_note text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_case public.price_mismatch_cases%rowtype;
  v_product public.products%rowtype;
  v_action text := upper(coalesce(nullif(btrim(p_action), ''), ''));
  v_note text := nullif(btrim(coalesce(p_note, '')), '');
  v_now timestamptz := now();
  v_admin uuid := auth.uid();
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_recheck boolean := false;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  if v_action not in ('RECHECK_NOW', 'APPLY_ML_PRICE', 'MARK_RESOLVED', 'MOVE_TO_STANDBY') then
    raise exception 'invalid_action';
  end if;

  select * into v_case
  from public.price_mismatch_cases
  where id = p_case_id
  for update;

  if not found then
    return jsonb_build_object('ok', false, 'error', 'case_not_found');
  end if;

  select * into v_product
  from public.products
  where id = v_case.product_id
  for update;

  if not found then
    return jsonb_build_object('ok', false, 'error', 'product_not_found');
  end if;

  if v_action = 'RECHECK_NOW' then
    v_recheck := public.enqueue_price_check_refresh(v_case.product_id, true, 'admin_mismatch_recheck');
  elsif v_action = 'APPLY_ML_PRICE' then
    update public.products
      set previous_price = case
            when coalesce(v_product.price, 0) > v_case.ml_price then v_product.price
            else previous_price
          end,
          previous_price_source = case
            when coalesce(v_product.price, 0) > v_case.ml_price then 'HISTORY'
            else previous_price_source
          end,
          previous_price_expires_at = case
            when coalesce(v_product.price, 0) > v_case.ml_price then (v_now + interval '48 hours')
            else previous_price_expires_at
          end,
          price = v_case.ml_price,
          data_health_status = 'HEALTHY',
          price_mismatch_status = 'RESOLVED',
          expected_price = null,
          site_price_snapshot = null,
          last_price_audit_at = v_now,
          price_mismatch_reason = null,
          price_mismatch_resolved_at = v_now,
          status = case
            when coalesce(v_product.is_active, false) = false
              and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(v_product.affiliate_link)
            then 'active'
            else status
          end,
          is_active = case
            when coalesce(v_product.is_active, false) = false
              and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(v_product.affiliate_link)
            then true
            else is_active
          end,
          deactivation_reason = case
            when coalesce(v_product.is_active, false) = false
              and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
              and public.is_mercadolivre_sec_link(v_product.affiliate_link)
            then null
            else deactivation_reason
          end,
          auto_disabled_reason = case
            when coalesce(v_product.is_active, false) = false
              and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(v_product.auto_disabled_reason, '')) = 'price_mismatch_critical'
              and public.is_mercadolivre_sec_link(v_product.affiliate_link)
            then null
            else auto_disabled_reason
          end,
          auto_disabled_at = case
            when coalesce(v_product.is_active, false) = false
              and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
              and lower(coalesce(v_product.auto_disabled_reason, '')) = 'price_mismatch_critical'
              and public.is_mercadolivre_sec_link(v_product.affiliate_link)
            then null
            else auto_disabled_at
          end,
          last_health_check_at = v_now,
          updated_at = v_now
    where id = v_case.product_id;

    update public.price_mismatch_cases
      set status = 'RESOLVED',
          resolved_at = v_now,
          resolved_by = coalesce(v_admin::text, 'service_role'),
          resolution_note = coalesce(v_note, 'apply_ml_price'),
          updated_at = v_now
    where id = v_case.id;
  elsif v_action = 'MARK_RESOLVED' then
    update public.price_mismatch_cases
      set status = 'RESOLVED',
          resolved_at = v_now,
          resolved_by = coalesce(v_admin::text, 'service_role'),
          resolution_note = coalesce(v_note, 'mark_resolved'),
          updated_at = v_now
    where id = v_case.id;

    if not exists (
      select 1
      from public.price_mismatch_cases c
      where c.product_id = v_case.product_id
        and c.status = 'OPEN'
        and c.id <> v_case.id
    ) then
      update public.products
        set price_mismatch_status = 'RESOLVED',
            price_mismatch_resolved_at = v_now,
            expected_price = null,
            site_price_snapshot = null,
            last_price_audit_at = v_now,
            price_mismatch_reason = null,
            status = case
              when coalesce(v_product.is_active, false) = false
                and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
                and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
                and public.is_mercadolivre_sec_link(v_product.affiliate_link)
              then 'active'
              else status
            end,
            is_active = case
              when coalesce(v_product.is_active, false) = false
                and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
                and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
                and public.is_mercadolivre_sec_link(v_product.affiliate_link)
              then true
              else is_active
            end,
            deactivation_reason = case
              when coalesce(v_product.is_active, false) = false
                and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
                and lower(coalesce(v_product.deactivation_reason, '')) in ('price_mismatch_critical', 'price_mismatch_review')
                and public.is_mercadolivre_sec_link(v_product.affiliate_link)
              then null
              else deactivation_reason
            end,
            auto_disabled_reason = case
              when coalesce(v_product.is_active, false) = false
                and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
                and lower(coalesce(v_product.auto_disabled_reason, '')) = 'price_mismatch_critical'
                and public.is_mercadolivre_sec_link(v_product.affiliate_link)
              then null
              else auto_disabled_reason
            end,
            auto_disabled_at = case
              when coalesce(v_product.is_active, false) = false
                and lower(coalesce(v_product.status, '')) in ('standby', 'needs_review', 'pending', 'pending_validacao', 'pending_validation')
                and lower(coalesce(v_product.auto_disabled_reason, '')) = 'price_mismatch_critical'
                and public.is_mercadolivre_sec_link(v_product.affiliate_link)
              then null
              else auto_disabled_at
            end,
            data_health_status = case
              when data_health_status = 'PRICE_MISMATCH' then 'HEALTHY'
              else data_health_status
            end,
            last_health_check_at = v_now,
            updated_at = v_now
      where id = v_case.product_id;
    end if;
  elsif v_action = 'MOVE_TO_STANDBY' then
    update public.products
      set status = 'standby',
          is_active = false,
          data_health_status = 'NEEDS_REVIEW',
          price_mismatch_status = 'OPEN',
          expected_price = v_case.ml_price,
          site_price_snapshot = v_product.price,
          price_mismatch_reason = coalesce(v_note, 'manual_mismatch_standby'),
          deactivation_reason = 'price_mismatch_review',
          last_price_audit_at = v_now,
          last_health_check_at = v_now,
          updated_at = v_now
    where id = v_case.product_id;
  end if;

  insert into public.product_admin_actions (
    product_id,
    admin_user_id,
    action,
    reason,
    note,
    details
  )
  values (
    v_case.product_id,
    v_admin,
    'price_mismatch_case_action',
    lower(v_action),
    v_note,
    jsonb_build_object(
      'case_id', v_case.id,
      'site_price', v_case.site_price,
      'ml_price', v_case.ml_price,
      'recheck_enqueued', v_recheck
    )
  );

  return jsonb_build_object(
    'ok', true,
    'action', lower(v_action),
    'case_id', v_case.id,
    'product_id', v_case.product_id,
    'recheck_enqueued', v_recheck
  );
end;
$$;

create or replace function public.get_admin_health_dashboard(
  p_lookback_hours integer default 24
)
returns jsonb
language plpgsql
security definer
set search_path = public, cron
as $$
declare
  v_now timestamptz := now();
  v_since timestamptz := now() - make_interval(hours => greatest(coalesce(p_lookback_hours, 24), 1));
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_admin uuid := auth.uid();
  v_cron jsonb := '[]'::jsonb;
  v_price_sync_last_run timestamptz;
  v_price_sync_runs_2h integer := 0;
  v_ingest_last_run timestamptz;
  v_ingest_last_inserted integer := 0;
  v_ingest_last_updated integer := 0;
  v_report_last_run timestamptz;
  v_report_delivery_status text;
  v_report_last_error text;
  v_standby_count integer := 0;
  v_active_count integer := 0;
  v_blocked_count integer := 0;
  v_active_without_affiliate integer := 0;
  v_invalid_affiliate_count integer := 0;
  v_invalid_not_permitted_count integer := 0;
  v_suspect_count integer := 0;
  v_mismatch_open_count integer := 0;
  v_mismatch_24h integer := 0;
  v_pix_count integer := 0;
  v_promo_count integer := 0;
  v_pix_present_count integer := 0;
  v_pix_missing_from_api_count integer := 0;
  v_pix_rejected_by_policy_count integer := 0;
  v_go_no_go text := 'OK';
  v_go_reason text := 'Automacao e catalogo dentro do esperado.';
  v_affiliate_errors jsonb := '[]'::jsonb;
  v_mismatch_top jsonb := '[]'::jsonb;
begin
  if not v_is_service and (v_admin is null or not public.has_role(v_admin, 'admin')) then
    raise exception 'admin_required';
  end if;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'jobname', j.jobname,
        'schedule', j.schedule,
        'active', j.active
      )
      order by j.jobname
    ),
    '[]'::jsonb
  )
  into v_cron
  from cron.job j
  where j.jobname in ('price-check-scheduler', 'catalog-ingest', 'price-sync-report');

  select max(started_at),
         count(*) filter (where started_at >= (v_now - interval '2 hours'))
  into v_price_sync_last_run, v_price_sync_runs_2h
  from public.price_sync_runs;

  select started_at, inserted_products, updated_products
  into v_ingest_last_run, v_ingest_last_inserted, v_ingest_last_updated
  from public.catalog_ingest_runs
  order by started_at desc
  limit 1;

  select coalesce(sent_at, created_at), delivery_status, last_error
  into v_report_last_run, v_report_delivery_status, v_report_last_error
  from public.price_sync_reports
  where source = 'price_sync_report'
  order by coalesce(sent_at, created_at) desc
  limit 1;

  select
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and (
          lower(coalesce(status, '')) in ('standby', 'pending', 'pending_validacao', 'pending_validation')
          or coalesce(is_active, false) = false
        )
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and coalesce(is_active, false) = true
        and lower(coalesce(status, '')) = 'active'
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and lower(coalesce(auto_disabled_reason, '')) = 'blocked'
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and coalesce(is_active, false) = true
        and lower(coalesce(status, '')) = 'active'
        and not public.is_mercadolivre_sec_link(affiliate_link)
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and affiliate_validation_status like 'INVALID_%'
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and affiliate_validation_status = 'INVALID_NOT_PERMITTED'
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and data_health_status = 'SUSPECT_PRICE'
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and coalesce(pix_price, 0) > 0
    ),
    count(*) filter (
      where lower(coalesce(marketplace, '')) like 'mercado%'
        and removed_at is null
        and (
          (
            coalesce(previous_price, 0) > coalesce(price, 0)
            and (previous_price_expires_at is null or previous_price_expires_at > v_now)
          )
          or (
            coalesce(original_price, 0) > coalesce(price, 0)
            and coalesce(discount_percentage, 0) > 0
          )
        )
    )
  into v_standby_count, v_active_count, v_blocked_count, v_active_without_affiliate,
       v_invalid_affiliate_count, v_invalid_not_permitted_count, v_suspect_count,
       v_pix_count, v_promo_count
  from public.products;

  select count(*),
         count(*) filter (where created_at >= v_since)
  into v_mismatch_open_count, v_mismatch_24h
  from public.price_mismatch_cases
  where status = 'OPEN';

  select
    count(*) filter (where coalesce(e.raw_api_pix, 0) > 0),
    count(*) filter (
      where e.event_status = 'updated'
        and coalesce(e.raw_api_price, 0) > 0
        and coalesce(e.raw_api_pix, 0) <= 0
    ),
    count(*) filter (
      where e.event_status = 'updated'
        and coalesce(e.raw_api_pix, 0) > 0
        and coalesce(e.final_price_source, '') <> 'API_PIX'
    )
  into v_pix_present_count, v_pix_missing_from_api_count, v_pix_rejected_by_policy_count
  from public.price_check_events e
  where e.created_at >= v_since
    and e.created_at <= v_now;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', p.id,
        'name', p.name,
        'status', p.status,
        'external_id', p.external_id,
        'affiliate_validation_status', p.affiliate_validation_status,
        'affiliate_validation_error', p.affiliate_validation_error,
        'updated_at', p.updated_at
      )
      order by p.updated_at desc
    ),
    '[]'::jsonb
  )
  into v_affiliate_errors
  from (
    select p.id, p.name, p.status, p.external_id, p.affiliate_validation_status, p.affiliate_validation_error, p.updated_at
    from public.products p
    where lower(coalesce(p.marketplace, '')) like 'mercado%'
      and p.removed_at is null
      and p.affiliate_validation_status like 'INVALID_%'
    order by p.updated_at desc
    limit 10
  ) p;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', c.id,
        'product_id', c.product_id,
        'product_name', p.name,
        'site_price', c.site_price,
        'ml_price', c.ml_price,
        'delta_abs', c.delta_abs,
        'delta_pct', c.delta_pct,
        'source', c.source,
        'reason', c.reason,
        'last_audit_at', c.last_audit_at
      )
      order by c.delta_pct desc, c.updated_at desc
    ),
    '[]'::jsonb
  )
  into v_mismatch_top
  from (
    select c.*
    from public.price_mismatch_cases c
    where c.status = 'OPEN'
    order by c.delta_pct desc, c.updated_at desc
    limit 10
  ) c
  join public.products p on p.id = c.product_id;

  if (
    (select count(*) from cron.job j where j.jobname in ('price-check-scheduler', 'catalog-ingest', 'price-sync-report') and j.active = true) < 3
  ) then
    v_go_no_go := 'PROBLEMA';
    v_go_reason := 'Cron job obrigatorio inativo ou ausente.';
  elsif v_active_without_affiliate > 0 then
    v_go_no_go := 'ATENCAO';
    v_go_reason := 'Existem produtos ativos sem link de afiliado valido.';
  elsif v_invalid_not_permitted_count > 0 or v_mismatch_open_count > 0 or v_suspect_count > 0 then
    v_go_no_go := 'ATENCAO';
    v_go_reason := 'Existem itens com falha de afiliado, mismatch de preco ou preco suspeito.';
  end if;

  return jsonb_build_object(
    'generated_at', v_now,
    'go_no_go', jsonb_build_object('state', v_go_no_go, 'reason', v_go_reason),
    'automation', jsonb_build_object(
      'cron_jobs', v_cron,
      'price_check_scheduler', jsonb_build_object(
        'last_run', v_price_sync_last_run,
        'runs_last_2h', coalesce(v_price_sync_runs_2h, 0)
      ),
      'catalog_ingest', jsonb_build_object(
        'last_run', v_ingest_last_run,
        'last_inserted', coalesce(v_ingest_last_inserted, 0),
        'last_updated', coalesce(v_ingest_last_updated, 0)
      ),
      'price_sync_report', jsonb_build_object(
        'last_run', v_report_last_run,
        'delivery_status', v_report_delivery_status,
        'last_error', v_report_last_error
      )
    ),
    'catalog', jsonb_build_object(
      'standby', coalesce(v_standby_count, 0),
      'active_ok', coalesce(v_active_count, 0),
      'blocked', coalesce(v_blocked_count, 0),
      'active_without_affiliate', coalesce(v_active_without_affiliate, 0),
      'affiliate_errors_total', coalesce(v_invalid_affiliate_count, 0),
      'affiliate_not_permitted', coalesce(v_invalid_not_permitted_count, 0)
    ),
    'prices', jsonb_build_object(
      'suspect_price', coalesce(v_suspect_count, 0),
      'mismatch_open', coalesce(v_mismatch_open_count, 0),
      'mismatch_last_24h', coalesce(v_mismatch_24h, 0),
      'pix_price', coalesce(v_pix_count, 0),
      'promotion_ready', coalesce(v_promo_count, 0),
      'pix_present_count', coalesce(v_pix_present_count, 0),
      'pix_missing_from_api_count', coalesce(v_pix_missing_from_api_count, 0),
      'pix_rejected_by_policy_count', coalesce(v_pix_rejected_by_policy_count, 0)
    ),
    'lists', jsonb_build_object(
      'affiliate_errors', v_affiliate_errors,
      'price_mismatch_top', v_mismatch_top
    )
  );
end;
$$;

create or replace function public.apply_affiliate_validation_batch(
  p_batch_id uuid,
  p_affiliate_urls text[]
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_batch public.affiliate_validation_batches%rowtype;
  v_now timestamptz := now();
  v_admin text := coalesce(auth.uid()::text, 'system');
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_links text[] := coalesce(p_affiliate_urls, array[]::text[]);
  v_links_count integer := coalesce(array_length(v_links, 1), 0);
  v_total_items integer := 0;
  v_applied integer := 0;
  v_invalid integer := 0;
  v_skipped integer := 0;
  v_ignored_extra integer := 0;
  v_old_status text;
  v_old_is_active boolean;
  v_old_affiliate text;
  v_link text;
  v_link_normalized text;
  rec record;
begin
  if not v_is_service and (auth.uid() is null or not public.has_role(auth.uid(), 'admin')) then
    raise exception 'admin_required';
  end if;

  select *
  into v_batch
  from public.affiliate_validation_batches
  where id = p_batch_id
  for update;

  if not found then
    raise exception 'batch_not_found';
  end if;

  if v_batch.status <> 'OPEN' then
    return jsonb_build_object(
      'ok', false,
      'batch_id', p_batch_id,
      'error', 'batch_not_open',
      'status', v_batch.status
    );
  end if;

  if v_batch.expires_at < v_now then
    update public.affiliate_validation_batches
      set status = 'EXPIRED'
    where id = p_batch_id;

    return jsonb_build_object(
      'ok', false,
      'batch_id', p_batch_id,
      'error', 'batch_expired',
      'status', 'EXPIRED'
    );
  end if;

  select count(*)
  into v_total_items
  from public.affiliate_validation_batch_items
  where batch_id = p_batch_id;

  for rec in
    select *
    from public.affiliate_validation_batch_items
    where batch_id = p_batch_id
    order by position
  loop
    if rec.position > v_links_count then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            error_message = 'missing_input_line',
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    v_link := btrim(coalesce(v_links[rec.position], ''));

    if v_link = '' then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            error_message = 'empty_link',
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    v_link_normalized := lower(coalesce(v_link, ''));

    if v_link_normalized like '%nao permitido%'
      or v_link_normalized like '%não permitido%'
      or v_link_normalized like '%nao e permitido%'
      or v_link_normalized like '%não e permitido%'
      or v_link_normalized like '%not permitted%'
      or v_link_normalized like '%url nao permitido%'
      or v_link_normalized like '%url não permitido%'
    then
      update public.products
        set affiliate_validation_status = 'INVALID_NOT_PERMITTED',
            affiliate_validation_error = 'URL nao permitido pelo Programa',
            status = 'standby',
            is_active = false,
            deactivation_reason = 'invalid_affiliate_not_permitted',
            last_health_check_at = v_now,
            updated_at = v_now
      where id = rec.product_id;

      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'affiliate_url_not_permitted',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    if not public.is_mercadolivre_sec_link(v_link) then
      update public.products
        set affiliate_validation_status = 'INVALID_LINK',
            affiliate_validation_error = 'Link de afiliado invalido',
            status = 'standby',
            is_active = false,
            deactivation_reason = 'invalid_affiliate_link',
            last_health_check_at = v_now,
            updated_at = v_now
      where id = rec.product_id;

      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'invalid_sec_link',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    if exists (
      select 1
      from public.products p
      where p.id <> rec.product_id
        and lower(coalesce(p.marketplace, '')) like 'mercado%'
        and p.affiliate_link = v_link
        and coalesce(p.is_active, false) = true
    ) then
      update public.products
        set affiliate_validation_status = 'INVALID_DUPLICATE',
            affiliate_validation_error = 'Link /sec/ ja vinculado em outro produto',
            status = 'standby',
            is_active = false,
            deactivation_reason = 'affiliate_link_already_used',
            last_health_check_at = v_now,
            updated_at = v_now
      where id = rec.product_id;

      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'affiliate_link_already_used',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    select status, is_active, affiliate_link
    into v_old_status, v_old_is_active, v_old_affiliate
    from public.products
    where id = rec.product_id
    for update;

    if not found then
      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'product_not_found',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    if coalesce(v_old_is_active, false) = true
      and lower(coalesce(v_old_status, '')) = 'active'
      and public.is_mercadolivre_sec_link(v_old_affiliate) then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            affiliate_url = v_link,
            error_message = 'already_validated',
            old_status = v_old_status,
            new_status = v_old_status,
            old_is_active = v_old_is_active,
            new_is_active = v_old_is_active,
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    update public.products
      set affiliate_link = v_link,
          affiliate_verified = true,
          affiliate_generated_at = coalesce(affiliate_generated_at, v_now),
          validated_at = coalesce(validated_at, v_now),
          validated_by = coalesce(validated_by, v_admin),
          affiliate_url_used = v_link,
          affiliate_validation_status = 'VALIDATED',
          affiliate_validation_error = null,
          status = 'active',
          is_active = true,
          auto_disabled_reason = null,
          auto_disabled_at = null,
          data_health_status = coalesce(data_health_status, 'HEALTHY'),
          deactivation_reason = null,
          next_check_at = coalesce(next_check_at, v_now),
          last_health_check_at = coalesce(last_health_check_at, v_now),
          updated_at = v_now
    where id = rec.product_id;

    insert into public.product_admin_actions (
      product_id,
      admin_user_id,
      action,
      reason,
      note,
      details
    )
    values (
      rec.product_id,
      auth.uid(),
      'affiliate_batch_applied',
      null,
      null,
      jsonb_build_object(
        'batch_id', p_batch_id,
        'position', rec.position,
        'link', v_link,
        'old_status', v_old_status,
        'old_is_active', v_old_is_active
      )
    );

    update public.affiliate_validation_batch_items
      set apply_status = 'APPLIED',
          affiliate_url = v_link,
          error_message = null,
          old_status = v_old_status,
          new_status = 'active',
          old_is_active = v_old_is_active,
          new_is_active = true,
          validated_by = v_admin,
          applied_at = v_now,
          updated_at = v_now
    where id = rec.id;

    v_applied := v_applied + 1;
  end loop;

  v_ignored_extra := greatest(v_links_count - v_total_items, 0);

  update public.affiliate_validation_batches
    set status = 'APPLIED',
        applied_at = v_now,
        total_items = v_total_items,
        applied_items = v_applied,
        invalid_items = v_invalid,
        ignored_extra = v_ignored_extra
  where id = p_batch_id;

  return jsonb_build_object(
    'ok', true,
    'batch_id', p_batch_id,
    'status', 'APPLIED',
    'total_items', v_total_items,
    'applied', v_applied,
    'invalid', v_invalid,
    'skipped', v_skipped,
    'ignored_extra', v_ignored_extra
  );
end;
$$;

grant execute on function public.admin_soft_remove_standby_products(uuid[], text, text) to authenticated, service_role;
grant execute on function public.run_price_mismatch_audit(integer, numeric, numeric, numeric, numeric, boolean) to authenticated, service_role;
grant execute on function public.auto_fix_open_price_mismatch_cases(integer, boolean) to authenticated, service_role;
grant execute on function public.queue_price_audit_sample(integer, boolean) to authenticated, service_role;
grant execute on function public.recheck_suspect_prices_now(integer) to authenticated, service_role;
grant execute on function public.admin_resolve_price_mismatch_case(uuid, text, text) to authenticated, service_role;
grant execute on function public.get_admin_health_dashboard(integer) to authenticated, service_role;
grant execute on function public.apply_affiliate_validation_batch(uuid, text[]) to authenticated, service_role;

commit;


-- Robust affiliate validation batches + safe offer redirect resolver.

create extension if not exists pgcrypto;

create table if not exists public.affiliate_validation_batches (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  created_by uuid null references auth.users(id) on delete set null,
  status text not null default 'OPEN',
  source text not null default 'admin',
  expires_at timestamptz not null default (now() + interval '24 hours'),
  applied_at timestamptz null,
  total_items integer not null default 0,
  applied_items integer not null default 0,
  invalid_items integer not null default 0,
  ignored_extra integer not null default 0,
  metadata jsonb not null default '{}'::jsonb
);

alter table public.affiliate_validation_batches
  drop constraint if exists affiliate_validation_batches_status_check;
alter table public.affiliate_validation_batches
  add constraint affiliate_validation_batches_status_check
  check (status in ('OPEN', 'APPLIED', 'EXPIRED'));

create table if not exists public.affiliate_validation_batch_items (
  id bigint generated by default as identity primary key,
  batch_id uuid not null references public.affiliate_validation_batches(id) on delete cascade,
  position integer not null,
  product_id uuid not null references public.products(id) on delete cascade,
  source_url text null,
  external_id text null,
  affiliate_url text null,
  apply_status text not null default 'PENDING',
  error_message text null,
  old_status text null,
  new_status text null,
  old_is_active boolean null,
  new_is_active boolean null,
  validated_by text null,
  applied_at timestamptz null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(batch_id, position),
  unique(batch_id, product_id)
);

alter table public.affiliate_validation_batch_items
  drop constraint if exists affiliate_validation_batch_items_apply_status_check;
alter table public.affiliate_validation_batch_items
  add constraint affiliate_validation_batch_items_apply_status_check
  check (apply_status in ('PENDING', 'APPLIED', 'INVALID', 'SKIPPED'));

alter table public.affiliate_validation_batch_items
  drop constraint if exists affiliate_validation_batch_items_position_check;
alter table public.affiliate_validation_batch_items
  add constraint affiliate_validation_batch_items_position_check
  check (position > 0);

create index if not exists idx_affiliate_validation_batches_status
  on public.affiliate_validation_batches(status, created_at desc);

create index if not exists idx_affiliate_validation_batch_items_batch
  on public.affiliate_validation_batch_items(batch_id, position);

create table if not exists public.product_offer_click_events (
  id bigint generated by default as identity primary key,
  product_id uuid not null references public.products(id) on delete cascade,
  click_source text not null default 'offer_redirect',
  resolved_source text null,
  resolution_reason text null,
  destination_url text null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index if not exists idx_product_offer_click_events_product
  on public.product_offer_click_events(product_id, created_at desc);

alter table public.affiliate_validation_batches enable row level security;
alter table public.affiliate_validation_batch_items enable row level security;
alter table public.product_offer_click_events enable row level security;

drop policy if exists "affiliate_validation_batches_admin_read" on public.affiliate_validation_batches;
create policy "affiliate_validation_batches_admin_read"
  on public.affiliate_validation_batches
  for select
  using (public.has_role(auth.uid(), 'admin'));

drop policy if exists "affiliate_validation_batches_admin_manage" on public.affiliate_validation_batches;
create policy "affiliate_validation_batches_admin_manage"
  on public.affiliate_validation_batches
  for all
  using (public.has_role(auth.uid(), 'admin'))
  with check (public.has_role(auth.uid(), 'admin'));

drop policy if exists "affiliate_validation_batch_items_admin_read" on public.affiliate_validation_batch_items;
create policy "affiliate_validation_batch_items_admin_read"
  on public.affiliate_validation_batch_items
  for select
  using (public.has_role(auth.uid(), 'admin'));

drop policy if exists "affiliate_validation_batch_items_admin_manage" on public.affiliate_validation_batch_items;
create policy "affiliate_validation_batch_items_admin_manage"
  on public.affiliate_validation_batch_items
  for all
  using (public.has_role(auth.uid(), 'admin'))
  with check (public.has_role(auth.uid(), 'admin'));

drop policy if exists "product_offer_click_events_admin_read" on public.product_offer_click_events;
create policy "product_offer_click_events_admin_read"
  on public.product_offer_click_events
  for select
  using (public.has_role(auth.uid(), 'admin'));

drop policy if exists "product_offer_click_events_service_insert" on public.product_offer_click_events;
create policy "product_offer_click_events_service_insert"
  on public.product_offer_click_events
  for insert
  to service_role
  with check (true);

create or replace function public.is_mercadolivre_sec_link(p_url text)
returns boolean
language sql
immutable
as $$
  select coalesce(p_url, '') ~* '^https?://(www\.)?mercadolivre\.com/sec/[A-Za-z0-9]+([/?#].*)?$';
$$;

create or replace function public.normalize_ml_external_id(p_value text)
returns text
language plpgsql
immutable
as $$
declare
  v_match text[];
  v_raw text;
begin
  if p_value is null then
    return null;
  end if;
  v_match := regexp_match(upper(p_value), '(MLB[-_ ]?[0-9]{6,14})');
  if v_match is null then
    return null;
  end if;
  v_raw := replace(replace(replace(v_match[1], '-', ''), '_', ''), ' ', '');
  if v_raw = '' then
    return null;
  end if;
  return v_raw;
end;
$$;

create or replace function public.normalize_ml_permalink(p_value text)
returns text
language plpgsql
immutable
as $$
declare
  v_clean text;
begin
  if p_value is null then
    return null;
  end if;
  v_clean := btrim(p_value);
  if v_clean = '' then
    return null;
  end if;
  v_clean := split_part(split_part(v_clean, '#', 1), '?', 1);
  v_clean := regexp_replace(v_clean, '/+$', '');
  if v_clean = '' then
    return null;
  end if;
  return lower(v_clean);
end;
$$;

create or replace function public.is_allowed_offer_url(
  p_url text,
  p_marketplace text default null
)
returns boolean
language plpgsql
immutable
as $$
declare
  v_url text;
  v_host text;
  v_market text;
begin
  v_url := btrim(coalesce(p_url, ''));
  if v_url = '' then
    return false;
  end if;
  if v_url !~* '^https?://' then
    return false;
  end if;

  v_host := lower(split_part(split_part(regexp_replace(v_url, '^https?://', '', 'i'), '/', 1), ':', 1));
  if v_host = '' then
    return false;
  end if;

  v_market := lower(coalesce(p_marketplace, ''));
  if v_market like '%mercado%' then
    return v_host like '%mercadolivre%' or v_host like '%mercadolibre%';
  end if;

  if v_market like '%amazon%' then
    return v_host = 'amzn.to' or v_host like '%amazon.%';
  end if;

  return true;
end;
$$;

create or replace function public.export_standby_affiliate_batch(
  p_limit integer default 30,
  p_source text default 'admin'
)
returns table(
  batch_id uuid,
  "position" integer,
  product_id uuid,
  product_name text,
  external_id text,
  source_url text
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_limit integer := greatest(1, least(coalesce(p_limit, 30), 30));
  v_batch_id uuid;
  v_inserted integer := 0;
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
begin
  if not v_is_service and (auth.uid() is null or not public.has_role(auth.uid(), 'admin')) then
    raise exception 'admin_required';
  end if;

  if auth.uid() is not null then
    update public.affiliate_validation_batches
      set status = 'EXPIRED'
    where status = 'OPEN'
      and created_by = auth.uid()
      and expires_at < now();
  else
    update public.affiliate_validation_batches
      set status = 'EXPIRED'
    where status = 'OPEN'
      and created_by is null
      and expires_at < now();
  end if;

  insert into public.affiliate_validation_batches (
    created_by,
    status,
    source,
    metadata
  )
  values (
    auth.uid(),
    'OPEN',
    coalesce(nullif(btrim(p_source), ''), 'admin'),
    jsonb_build_object('limit', v_limit)
  )
  returning id into v_batch_id;

  with pending_raw as (
    select
      p.id as product_id,
      p.name as product_name,
      p.status,
      p.is_active,
      p.affiliate_verified,
      p.external_id,
      p.last_sync,
      p.updated_at,
      p.created_at,
      coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), '')) as source_url,
      coalesce(
        public.normalize_ml_external_id(coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), ''))),
        public.normalize_ml_permalink(coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), ''))),
        public.normalize_ml_external_id(p.external_id),
        public.normalize_ml_external_id(p.source_url),
        public.normalize_ml_external_id(p.affiliate_link),
        public.normalize_ml_permalink(coalesce(p.source_url, p.affiliate_link)),
        p.id::text
      ) as canonical_key
    from public.products p
    where lower(coalesce(p.marketplace, '')) like 'mercado%'
      and coalesce(p.auto_disabled_reason, '') <> 'blocked'
      and coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), '')) is not null
      and (
        lower(coalesce(p.status, '')) in ('standby', 'pending', 'pending_validacao', 'pending_validation')
        or coalesce(p.is_active, false) = false
        or coalesce(p.affiliate_verified, false) = false
        or not public.is_mercadolivre_sec_link(p.affiliate_link)
      )
  ),
  active_validated as (
    select distinct
      av.canonical_key
    from (
      select
        p.id as product_id,
        coalesce(
          public.normalize_ml_external_id(coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), ''))),
          public.normalize_ml_permalink(coalesce(nullif(btrim(p.source_url), ''), nullif(btrim(p.affiliate_link), ''))),
          public.normalize_ml_external_id(p.external_id),
          public.normalize_ml_external_id(p.source_url),
          public.normalize_ml_external_id(p.affiliate_link),
          public.normalize_ml_permalink(coalesce(p.source_url, p.affiliate_link)),
          p.id::text
        ) as canonical_key
      from public.products p
      where lower(coalesce(p.marketplace, '')) like 'mercado%'
        and coalesce(p.auto_disabled_reason, '') <> 'blocked'
        and coalesce(p.is_active, false) = true
        and lower(coalesce(p.status, '')) = 'active'
        and public.is_mercadolivre_sec_link(p.affiliate_link)
    ) av
    where av.canonical_key is not null
  ),
  deduped as (
    select
      pr.*,
      row_number() over (
        partition by pr.canonical_key
        order by
          case when coalesce(pr.affiliate_verified, false) then 0 else 1 end,
          case when coalesce(pr.is_active, false) then 0 else 1 end,
          coalesce(pr.last_sync, pr.updated_at, pr.created_at) asc,
          pr.product_id
      ) as canon_rank
    from pending_raw pr
    left join active_validated av on av.canonical_key = pr.canonical_key
    where av.canonical_key is null
  ),
  ordered as (
    select
      d.product_id,
      d.product_name,
      d.external_id,
      d.source_url,
      row_number() over (
        order by
          case when lower(coalesce(d.status, '')) = 'standby' then 0 else 1 end,
          coalesce(d.last_sync, d.updated_at, d.created_at) asc,
          d.product_id
      ) as position
    from deduped d
    where d.canon_rank = 1
  )
  insert into public.affiliate_validation_batch_items (
    batch_id,
    position,
    product_id,
    source_url,
    external_id
  )
  select
    v_batch_id,
    o.position,
    o.product_id,
    o.source_url,
    public.normalize_ml_external_id(o.external_id)
  from ordered o
  where o.position <= v_limit;

  get diagnostics v_inserted = row_count;

  if v_inserted = 0 then
    delete from public.affiliate_validation_batches where id = v_batch_id;
    return;
  end if;

  update public.affiliate_validation_batches
    set total_items = (
      select count(*)
      from public.affiliate_validation_batch_items i
      where i.batch_id = v_batch_id
    )
  where id = v_batch_id;

  return query
  select
    v_batch_id as batch_id,
    i.position,
    i.product_id,
    p.name as product_name,
    i.external_id,
    i.source_url
  from public.affiliate_validation_batch_items i
  join public.products p on p.id = i.product_id
  where i.batch_id = v_batch_id
  order by i.position;
end;
$$;

create or replace function public.apply_affiliate_validation_batch(
  p_batch_id uuid,
  p_affiliate_urls text[]
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_batch public.affiliate_validation_batches%rowtype;
  v_now timestamptz := now();
  v_admin text := coalesce(auth.uid()::text, 'system');
  v_is_service boolean := coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role';
  v_links text[] := coalesce(p_affiliate_urls, array[]::text[]);
  v_links_count integer := coalesce(array_length(v_links, 1), 0);
  v_total_items integer := 0;
  v_applied integer := 0;
  v_invalid integer := 0;
  v_skipped integer := 0;
  v_ignored_extra integer := 0;
  v_old_status text;
  v_old_is_active boolean;
  v_old_affiliate text;
  v_link text;
  rec record;
begin
  if not v_is_service and (auth.uid() is null or not public.has_role(auth.uid(), 'admin')) then
    raise exception 'admin_required';
  end if;

  select *
  into v_batch
  from public.affiliate_validation_batches
  where id = p_batch_id
  for update;

  if not found then
    raise exception 'batch_not_found';
  end if;

  if v_batch.status <> 'OPEN' then
    return jsonb_build_object(
      'ok', false,
      'batch_id', p_batch_id,
      'error', 'batch_not_open',
      'status', v_batch.status
    );
  end if;

  if v_batch.expires_at < v_now then
    update public.affiliate_validation_batches
      set status = 'EXPIRED'
    where id = p_batch_id;

    return jsonb_build_object(
      'ok', false,
      'batch_id', p_batch_id,
      'error', 'batch_expired',
      'status', 'EXPIRED'
    );
  end if;

  select count(*)
  into v_total_items
  from public.affiliate_validation_batch_items
  where batch_id = p_batch_id;

  for rec in
    select *
    from public.affiliate_validation_batch_items
    where batch_id = p_batch_id
    order by position
  loop
    if rec.position > v_links_count then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            error_message = 'missing_input_line',
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    v_link := btrim(coalesce(v_links[rec.position], ''));

    if v_link = '' then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            error_message = 'empty_link',
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    if not public.is_mercadolivre_sec_link(v_link) then
      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'invalid_sec_link',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    if exists (
      select 1
      from public.products p
      where p.id <> rec.product_id
        and lower(coalesce(p.marketplace, '')) like 'mercado%'
        and p.affiliate_link = v_link
        and coalesce(p.is_active, false) = true
    ) then
      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'affiliate_link_already_used',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    select status, is_active, affiliate_link
    into v_old_status, v_old_is_active, v_old_affiliate
    from public.products
    where id = rec.product_id
    for update;

    if not found then
      update public.affiliate_validation_batch_items
        set apply_status = 'INVALID',
            affiliate_url = v_link,
            error_message = 'product_not_found',
            updated_at = v_now
      where id = rec.id;
      v_invalid := v_invalid + 1;
      continue;
    end if;

    if coalesce(v_old_is_active, false) = true
      and lower(coalesce(v_old_status, '')) = 'active'
      and public.is_mercadolivre_sec_link(v_old_affiliate) then
      update public.affiliate_validation_batch_items
        set apply_status = 'SKIPPED',
            affiliate_url = v_link,
            error_message = 'already_validated',
            old_status = v_old_status,
            new_status = v_old_status,
            old_is_active = v_old_is_active,
            new_is_active = v_old_is_active,
            updated_at = v_now
      where id = rec.id;
      v_skipped := v_skipped + 1;
      continue;
    end if;

    update public.products
      set affiliate_link = v_link,
          affiliate_verified = true,
          affiliate_generated_at = coalesce(affiliate_generated_at, v_now),
          validated_at = coalesce(validated_at, v_now),
          validated_by = coalesce(validated_by, v_admin),
          affiliate_url_used = v_link,
          status = 'active',
          is_active = true,
          auto_disabled_reason = null,
          auto_disabled_at = null,
          data_health_status = coalesce(data_health_status, 'HEALTHY'),
          deactivation_reason = null,
          next_check_at = coalesce(next_check_at, v_now),
          last_health_check_at = coalesce(last_health_check_at, v_now)
    where id = rec.product_id;

    update public.affiliate_validation_batch_items
      set apply_status = 'APPLIED',
          affiliate_url = v_link,
          error_message = null,
          old_status = v_old_status,
          new_status = 'active',
          old_is_active = v_old_is_active,
          new_is_active = true,
          validated_by = v_admin,
          applied_at = v_now,
          updated_at = v_now
    where id = rec.id;

    v_applied := v_applied + 1;
  end loop;

  v_ignored_extra := greatest(v_links_count - v_total_items, 0);

  update public.affiliate_validation_batches
    set status = 'APPLIED',
        applied_at = v_now,
        total_items = v_total_items,
        applied_items = v_applied,
        invalid_items = v_invalid,
        ignored_extra = v_ignored_extra
  where id = p_batch_id;

  return jsonb_build_object(
    'ok', true,
    'batch_id', p_batch_id,
    'status', 'APPLIED',
    'total_items', v_total_items,
    'applied', v_applied,
    'invalid', v_invalid,
    'skipped', v_skipped,
    'ignored_extra', v_ignored_extra
  );
end;
$$;

create or replace function public.resolve_product_offer_url(
  p_product_id uuid,
  p_allow_redirect_while_standby boolean default false,
  p_click_source text default 'offer_click',
  p_metadata jsonb default '{}'::jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_product public.products%rowtype;
  v_marketplace text;
  v_status text;
  v_is_active boolean;
  v_is_mercado boolean;
  v_affiliate text;
  v_source text;
  v_target text := null;
  v_target_source text := null;
  v_reason text := null;
begin
  select *
  into v_product
  from public.products
  where id = p_product_id;

  if not found then
    return jsonb_build_object(
      'ok', false,
      'can_redirect', false,
      'reason', 'not_found',
      'url', null
    );
  end if;

  v_marketplace := lower(coalesce(v_product.marketplace, ''));
  v_status := lower(coalesce(v_product.status, ''));
  v_is_active := coalesce(v_product.is_active, false) or v_status = 'active';
  v_is_mercado := v_marketplace like '%mercado%';
  v_affiliate := nullif(btrim(coalesce(v_product.affiliate_link, '')), '');
  v_source := nullif(btrim(coalesce(v_product.source_url, '')), '');

  if lower(coalesce(v_product.auto_disabled_reason, '')) = 'blocked' then
    v_reason := 'blocked_by_policy';
  elsif v_is_mercado then
    if v_is_active and public.is_mercadolivre_sec_link(v_affiliate) then
      v_target := v_affiliate;
      v_target_source := 'affiliate';
      v_reason := 'affiliate_validated';
    elsif p_allow_redirect_while_standby and v_source is not null then
      v_target := v_source;
      v_target_source := 'source';
      v_reason := 'standby_source_allowed';
    else
      v_reason := 'awaiting_affiliate_validation';
    end if;
  else
    if v_is_active and v_affiliate is not null then
      v_target := v_affiliate;
      v_target_source := 'affiliate';
      v_reason := 'affiliate_active';
    elsif (v_is_active or p_allow_redirect_while_standby) and v_source is not null then
      v_target := v_source;
      v_target_source := 'source';
      v_reason := 'source_fallback';
    else
      v_reason := 'missing_offer_url';
    end if;
  end if;

  if v_target is not null and not public.is_allowed_offer_url(v_target, v_product.marketplace) then
    v_target := null;
    v_target_source := null;
    v_reason := 'invalid_target_domain';
  end if;

  begin
    insert into public.product_offer_click_events (
      product_id,
      click_source,
      resolved_source,
      resolution_reason,
      destination_url,
      metadata
    )
    values (
      v_product.id,
      coalesce(nullif(btrim(p_click_source), ''), 'offer_click'),
      v_target_source,
      v_reason,
      v_target,
      coalesce(p_metadata, '{}'::jsonb) || jsonb_build_object(
        'allow_redirect_while_standby', p_allow_redirect_while_standby,
        'status', v_product.status,
        'is_active', v_product.is_active,
        'marketplace', v_product.marketplace
      )
    );
  exception when others then
    null;
  end;

  return jsonb_build_object(
    'ok', v_target is not null,
    'can_redirect', v_target is not null,
    'url', v_target,
    'resolved_source', v_target_source,
    'reason', v_reason,
    'product_id', v_product.id,
    'status', v_product.status,
    'is_active', v_product.is_active,
    'allow_redirect_while_standby', p_allow_redirect_while_standby
  );
end;
$$;

grant execute on function public.export_standby_affiliate_batch(integer, text) to authenticated, service_role;
grant execute on function public.apply_affiliate_validation_batch(uuid, text[]) to authenticated, service_role;
grant execute on function public.resolve_product_offer_url(uuid, boolean, text, jsonb) to anon, authenticated, service_role;
grant execute on function public.is_mercadolivre_sec_link(text) to anon, authenticated, service_role;
grant execute on function public.is_allowed_offer_url(text, text) to anon, authenticated, service_role;
grant execute on function public.normalize_ml_external_id(text) to anon, authenticated, service_role;
grant execute on function public.normalize_ml_permalink(text) to anon, authenticated, service_role;
